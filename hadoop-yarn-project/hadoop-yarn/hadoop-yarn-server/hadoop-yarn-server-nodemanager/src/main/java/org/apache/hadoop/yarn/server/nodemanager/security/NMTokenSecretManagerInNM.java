/**
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package org.apache.hadoop.yarn.server.nodemanager.security;

import java.util.HashMap;
import java.util.Map;

import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;
import org.apache.hadoop.classification.InterfaceAudience.Private;
import org.apache.hadoop.yarn.api.records.ApplicationAttemptId;
import org.apache.hadoop.yarn.security.NMTokenIdentifier;
import org.apache.hadoop.yarn.server.api.records.MasterKey;
import org.apache.hadoop.yarn.server.security.BaseNMTokenSecretManager;
import org.apache.hadoop.yarn.server.security.MasterKeyData;

public class NMTokenSecretManagerInNM extends BaseNMTokenSecretManager {

  private static final Log LOG = LogFactory
    .getLog(NMTokenSecretManagerInNM.class);
  
  private MasterKeyData previousMasterKey;
  
  private final Map<ApplicationAttemptId, MasterKeyData> oldMasterKeys;
  
  public NMTokenSecretManagerInNM() {
    this.oldMasterKeys =
        new HashMap<ApplicationAttemptId, MasterKeyData>();
  }
  
  /**
   * Used by NodeManagers to create a token-secret-manager with the key
   * obtained from the RM. This can happen during registration or when the RM
   * rolls the master-key and signal the NM.
   */
  @Private
  public synchronized void setMasterKey(MasterKey masterKey) {
    LOG.info("Rolling master-key for nm-tokens, got key with id :"
        + masterKey.getKeyId());
    if (super.currentMasterKey == null) {
      super.currentMasterKey =
          new MasterKeyData(masterKey, createSecretKey(masterKey.getBytes()
            .array()));
    } else {
      if (super.currentMasterKey.getMasterKey().getKeyId() != masterKey
        .getKeyId()) {
        this.previousMasterKey = super.currentMasterKey;
        super.currentMasterKey =
            new MasterKeyData(masterKey, createSecretKey(masterKey.getBytes()
              .array()));
      }
    }
  }

  /**
   * This method will be used to verify NMTokens generated by different
   * master keys.
   */
  @Override
  public synchronized byte[] retrievePassword(
      NMTokenIdentifier identifier) throws InvalidToken {
    int keyId = identifier.getMastKeyId();
    ApplicationAttemptId appAttemptId = identifier.getApplicationAttemptId();
    
    /*
     * MasterKey used for retrieving password will be as follows.
     * 1) By default older saved master key will be used.
     * 2) If identifier's master key id matches that of previous master key
     * id then previous key will be used.
     * 3) If identifier's master key id matches that of current master key
     * id then current key will be used.
     */
    MasterKeyData oldMasterKey = oldMasterKeys.get(appAttemptId);
    MasterKeyData masterKeyToUse = oldMasterKey;
    if (previousMasterKey != null
        && keyId == previousMasterKey.getMasterKey().getKeyId()) {
      masterKeyToUse = previousMasterKey;
    } else if ( keyId == currentMasterKey.getMasterKey().getKeyId()) {
      masterKeyToUse = currentMasterKey;
    }
    
    if (masterKeyToUse != null) {
      byte[] password = retrivePasswordInternal(identifier, masterKeyToUse);
      if (masterKeyToUse.getMasterKey().getKeyId() != oldMasterKey
        .getMasterKey().getKeyId()) {
        oldMasterKeys.put(appAttemptId, masterKeyToUse);
      }
      return password;
    }
    
    throw new InvalidToken("Given NMToken for application : "
        + appAttemptId.toString() + " seems to have been generated illegally.");
  }
  
  public synchronized void appFinished(ApplicationAttemptId appAttemptId) {
    this.oldMasterKeys.remove(appAttemptId);
  }
}
